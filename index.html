<html>

<head>

    <title>
        GtL (Beta)
    </title>

</head>

<body>

    <canvas id="myCanvas" width=x height=y style="border:1px solid #000000;"> </canvas>
    
    <div style="margin-left: 10px;">
    
        <h3 id="selection">
            Edit Mode
        </h3> 
        
        <input type="search" placeholder="Preview" id="preview" disabled="true" hidden="true">

        <table style="text-align: left;">

            <tr>
                <th> <b style="font-size: 10px;">Drawing Functionality:</b> </th>            
                <th> <button onclick="set_mode(1)"> Circle </button> </th>
                <th> <button onclick="set_mode(2)"> Square </button> </th>
                <th> <button onclick="set_mode(5)"> Text </button> </th>                
                <th> <button onclick="set_mode(3)"> Line </button> </th>
            </tr>
            <tr>
                <th> <b style="font-size: 10px;">Editing Functionality:</b> </th>                
                <th> <button onclick="switch_grid_status()"> Grid </button> </th>
                <th> <button onclick="switch_curve_status()"> Curve </button> </th>
                <th> <button onclick="clear_canvas(clear_objects=true)"> Clear </button> </th>                                    
                <th> <button onclick="set_mode(4)"> Edit </button> </th>                
            </tr>
            <tr>
                <th> <b style="font-size: 10px;">Scaling:</b> </th>
                <th> <button onclick="scale('+')"> + </button> </th>
                <th> <button onclick="scale('-')"> - </button> </th>                
            </tr>

        </table>
        
        <br>

        <button onclick="safe()"> Safe Graph to File</button>

        <br>

        <button onclick="load_from_json();"> Load Graph </button>
        <input type="file" value="Load">
        
        <br>
        
        <h5 id="mouse" hidden="true"> 0,0 </h5>
        
        <br>
        
        <i style="color: #d0d0d0; font-size: 10px;">GtL (Beta) by @Maximilian L&ouml;ffler</i>
    
    </div>

    <script type="text/javascript" src="objects.js"></script>
    <script type="text/javascript" src="helpers.js"></script>
    <script type="text/javascript" src="grid_functions.js"></script>
    <script type="text/javascript" src="global_varibales.js"></script>

    <script>

    let set_mode = function(param) {
        mode = param;
    }

    let config = function() {
        var display = document.getElementById('selection');
        switch(mode) {
            case 4: display.style.color = "red"; break;
            default: display.style.color = "black"; break;
        }
        switch(mode) {
            case 1: display.innerHTML = "Circle Selected"; break;
            case 2: display.innerHTML = "Square Selected"; break;
            case 3: display.innerHTML = "Line Selected"; break;
            case 4: display.innerHTML = "Edit Mode"; break;
            case 5: display.innerHTML = "Text Selected"; break;
            default: throw new Error("System in invalid mode"); break;
        }
    }

    let rescale_canvas = function() {
        x = document.body.clientWidth;
        y = document.body.clientHeight;

        c = document.getElementById('myCanvas');
        c.width = x;
        c.height = y / 1.3;

        document.body.style.marginLeft = 0;
        document.body.style.marginRight = 0;
        document.body.style.marginTop = 0;

        if (grid_status) {
            regrid();
        }
        draw();
    }

    function scale(op) {
        if (op == "+") {
            griding  -= 5;
            radius   += 5;
            square_h += 5;
            square_w += 10;
        } else {
            griding  += 5;
            radius   -= 5;
            square_h -= 5;
            square_w -= 10;
        }
        if (grid_status) {
            regrid();
        }
        draw();
    }

    let clear_canvas = function(clear_objects) {
        c = document.getElementById('myCanvas');
        ctx = c.getContext('2d');
        ctx.fillStyle = "#e0e0e0";
        ctx.fillRect(0, 0, c.width, c.height);
        
        if (grid_status) {
            grid();
        }

        if (clear_objects) {
            objects = [];
            lines = [];
        }
    }

    let draw = function() {
        
        clear_canvas(clear_objects=false);

        for (var i = 0; i < lines.length; i++) {
            s = lines[i].s;
            e = lines[i].e;

            ctx.strokeStyle = 'black';

            // the line
            ctx.beginPath();
            ctx.moveTo(s.get_x(), s.get_y());
            if (curve_status) {
                x_diff = (e.get_x() - s.get_x()) / 5;
                y_diff = s.get_y() - e.get_y();
                y_diff =  y_diff > 0 ? Math.abs(y_diff) / 2 : -Math.abs(y_diff) / 2;
                bez_1_x = s.get_x() + x_diff * 1.5;
                bez_1_y = s.get_y() - y_diff * 1.5;
                bez_2_x = e.get_x() - x_diff * 2;
                bez_2_y = e.get_y() - y_diff / 8;
                ctx.bezierCurveTo(bez_1_x, bez_1_y, bez_2_x, bez_2_y, e.get_x(), e.get_y())                
            } else {
                ctx.lineTo(e.get_x(), e.get_y());
            }
            ctx.stroke();

            // the "triangle"
            ctx.beginPath();
            ctx.arc(e.get_x(), e.get_y(), 5, 0, 2 * Math.PI);
            ctx.fillStyle = "black";
            ctx.fill();
        }

        for (var i = 0; i < objects.length; i++) {
            
            x = objects[i].get_x();
            y = objects[i].get_y();
            type = objects[i].type;

            if (type == "circle") {
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = "white";
                ctx.fill();
            } else if (type == "square") {
                if (!objects[i].is_text()) {
                    ctx.beginPath();
                    ctx.rect(x - square_w / 2, y - square_h / 2, square_w, square_h);
                    ctx.fillStyle = "white";
                    ctx.fill();
                } 
            }

            ctx.fillStyle = objects[i].get_color();
            ctx.strokeStyle = objects[i].get_color();
            
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.font = text_size + " Arial";
            ctx.textAlign = "center";
            ctx.fillText(objects[i].get_content(), x, y + 6);
        }
    }

    let switch_curve_status = function() { 
        curve_status = !curve_status;
        draw(); 
    };

    let check_approx = function(x, y) {
        for (var i = 0; i < objects.length; i++) {
            if (objects[i].in(x, y)) {
                if (!objects[i].selected) {
                    read = true;
                    document.getElementById('preview').placeholder = objects[i].get_content();
                    objects[i].select();
                    last_selected = i;
                } else {
                    if (objects[i].moveable) {
                        read = false;
                        document.getElementById('preview').placeholder = "Preview";
                        objects[i].deselect();
                    } else {
                        read = false;
                        objects[i].moveable = true;
                        close_edit();
                    }  
                }
            } else {
                if (!event.shiftKey) {
                    objects[i].deselect();
                    objects[i].moveable = false;
                }
            }
        }
    }

    let close_edit = function() {
        document.getElementById('preview').value = "";
        document.getElementById('preview').placeholder = "Preview";
        document.getElementById('preview').disabled = true;
        document.getElementById('preview').hidden = true;
    }

    let rename_node = function() {
        con = translation_table(document.getElementById('preview').value);        
        for (var i = 0; i < objects.length; i++) {
            if (objects[i].selected) {
                objects[i].content = con;
                objects[i].deselect();
                close_edit();
            }
        }
        draw();
    }
    
    onmousemove = function(e){
        document.getElementById('mouse').innerHTML = e.clientX + ", " + e.clientY;
        config();
        
        selection = new Selection();

        if (mode == 4) {
            center = null;
            for (var i = 0; i < objects.length; i++) {
                if (objects[i].selected && i != last_selected) {
                    selection.add(i, objects[i]);
                }
            }
            selection.add(last_selected, objects[last_selected]);
            if (!selection.valid()) {
                for (var i = 0; i < objects.length; i++) {
                    type = objects[i].type;
                    if (!event.shiftKey) {
                        if (objects[i].moveable) {
                            if (grid_status) {
                                x,y = get_closest_grid_point(e.clientX, e.clientY);                                
                                objects[i].set_x(x);
                                objects[i].set_y(y);
                            } else {
                                objects[i].set_x(e.clientX);
                                objects[i].set_y(e.clientY);
                            }
                            draw();
                        }
                    }
                }
            } else {
                if (!event.shiftKey) {
                    close_edit();
                    for (var i = 0; i < selection.elements.length; i++) {
                        element = selection.elements[i];

                        x_sel = e.clientX + element[1][1];
                        y_sel = e.clientY + element[1][2];

                        if (grid_status) {
                            x,y = get_closest_grid_point(x_sel, y_sel);
                            objects[element[0]].set_x(x);
                            objects[element[0]].set_y(y);
                        } else {
                            objects[element[0]].set_x(x_sel);
                            objects[element[0]].set_y(y_sel);
                        }
                    }
                    draw();
                }
            }
        } 
        if (mode == 3 && start_point != null) {
            lines.push(new Line(start_point, new Dot(e.clientX, e.clientY)));
            draw();
            lines.splice(lines.length - 1, 1);
        }
    }
    
    document.getElementById('myCanvas').onmousedown = function(e){

        x = e.clientX;
        y = e.clientY;
        
        if (grid_status) {
            x,y = get_closest_grid_point(e.clientX, e.clientY);
        }

        if (mode == 1) {
            objects.push(new Circle(new Dot(x, y), objects.length));
        } else if (mode == 2) {
            objects.push(new Square(new Dot(x, y), objects.length, false));
        } else if (mode == 5) {
            objects.push(new Square(new Dot(x, y), objects.length, true));
        } else if (mode == 3) {
            if (init_line) {
                start_point = new Dot(x, y);
                for (var i = 0; i < objects.length; i++) {
                    if (objects[i].in(e.clientX, e.clientY)) {
                        start_point = objects[i].center;
                    }
                } 
                init_line = false;
            } else {
                end_point = new Dot(x, y);
                for (var i = 0; i < objects.length; i++) {
                    if (objects[i].in(e.clientX, e.clientY)) {
                        end_point = objects[i].center;
                    }
                }
                if (start_point.x != end_point.x || start_point.y != end_point.y) {
                    lines.push(new Line(start_point, end_point));
                }
                start_point = null;
                init_line = true;
            }
        } else {
            check_approx(e.clientX, e.clientY);
        }
        draw();
    }

    document.onkeydown = function (e) {
        e = e || window.event;
        if (mode == 4 && !read) {
            if (e.key == "Backspace") {
                for (var i = 0; i < objects.length; i++) {
                    if (objects[i].selected) {
                        for (var j = 0; j < lines.length; j++) {
                            if (lines[j].e == objects[i].center || lines[j].s == objects[i].center) {
                                lines.splice(j, 1);        
                            }
                        }
                        objects.splice(i, 1);
                        draw();
                    }
                }
            }
        } else if (mode == 4 && read) {
            document.getElementById('preview').focus();
            document.getElementById('preview').disabled = false;
            document.getElementById('preview').hidden = false;
            if (e.key == "Enter") {
                rename_node();
            }
        }
        if (mode == 3) {
            if (start_point != null) {
                if (e.key == "Escape") {
                    init_line = true;
                    start_point = null;
                    draw();
                }
            }
        }
    };

    window.onresize = rescale_canvas;
    window.onload = function(e) {
        rescale_canvas();
        draw();
    }

    </script>

</body>

</html>